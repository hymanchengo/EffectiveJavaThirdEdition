### 条款1：考虑用静态工厂方法替代构造函数
类提供客户端获取对象实例的一个传统方式是提供开一个公有构造函数。另一项技术应该纳入每个程序员工具箱。
类可以提供一个共有的静态工厂方法，该静态方法仅仅返回这个类的实例。下面是Boolean(boolean的装箱基本类)的一个简单例子。
这个方法将boolean基本值转换成一个Boolean对象引用.
```java
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```
注意这边的静态工厂方法和设计模式中的静态工厂方法模式是不一样的。本条款描述的静态工厂方法在设计模式中
没有直接的对等项。

  类可以只提供客户端静态工厂方法，而不提供公有构造函数，或者两者都提供。只提供静态工厂方法而不提供公有构造函数既有优点
也有缺点。

  **静态工厂方法的一个优点是，不同于构造函数，他们是有命名的**

    如果构造函数的参数本身不描述返回的对象，具有精心挑选的静态工厂方法则更容易使用，客户端代码将更加可读。比如
    构造函数BigInteger(int, int, Random),返回一个可能是素数的BigInteger，如果用名为BigInteger.problePrime的静
    态工厂方法来表达将会更好（这个方法已添加到Java 4中）
    
    一个类只能有一个给定方法签名的单一构造函数。程序员们通常提供两个参数列表仅仅参数类型顺序不同的方式来绕过这个限制
    。这个注意有点糟糕。这样的API用户将不能记得哪个构造函数是哪个，最终可能使用了错误的那个构造函数。读到这段使用这些
    构造函数的代码的人如果不参考类的文档将不理解这段代码干了什么。
   
    因为有命名，静态工厂方法将不受到上述段落表达的限制。在一个类看起来需要相同签名的多个构造函数时，使用静态工厂方法来
    替换构造函数，并谨慎地选择能强调他们区别的命名
    
  **静态工厂方法的第二个优点是，不同于构造函数，他们被调用的时候，不是每次都需要创建一个新的对象**
  
    这使得不可变类能使用预构造的实例，或者缓存已经构造的实例，重复分配他们，避免创建不必要的重复对象。
    Boolean.valueOf(boolean)方法说明了这项技术，它从不创建一个对象。这项技术和共享元模式类似。如果
    同等对象经常用到，这项技术可以极大地提升性能，尤其是在对象创建很耗资源的时候。
    
    静态工厂方法通过重复调用返回相同对象的能力使得类能维持对任何时候存在的实例的严格控制。干这些的类
    被称为"控制实例的"。编写控制实例的类有这么几个原因。实例控制确保一个类是单实例或者不可实例化的。同样它能确保
    不可变值得类没有两个相同实例存在: a.equals(b) 只有a == b时才成立。这是共享元模式的基础。枚举类型提供了保障。
    
    
   **静态工厂方法的第三个优点是，不同于构造函数，它们可以生成返回类型任何子类的对象**
   
    这点给了我们极大的弹性选择要返回对象的类
    该弹性的一个应用是一个API可以返回不必是公共类的对象。以这种形式隐藏实现类形成一个非常紧凑的API。这个技术被基于接口
    的框架借用。这些框架的接口为原生的静态工厂方法提供返回类型。Java 8之前，接口不能包含静态方法。按照惯例，一个Type接口的
    静态工厂方法是放在一个不可实例化的协作类中。比如Java集合框架的接口有45个工具实现。提供了不可修改的集合，同步集合等等。
    几乎所有的这些实现类是通过一个不可实例化的类的静态工厂方法导出的。这些返回对象所属的类都是非公共的。
    比起导出45个独立的公共类,每个方便的实现，集合框架API要小得多。这不仅仅是API块减小了，概念上也更加清晰：程序员不必再苦于
    为使用API需要掌握概念的数量和难度。程序员知道返回对象恰好具有其接口指定的API，所以没必要再额外阅读实现类的文档。
    再者，使用这样的一个静态工厂方法需要客户端通过接口来引用返回的对象而不是实现类，这通常是一个很好的实践。
    
    Java8中，接口不能包含静态方法的限制被取消了，所以没必要再为接口提供一个不可实例化的协同类。许多公共的静态成员
    原本处于这样的协同类里的现在应该被放到接口本身中。注意，然而，也许仍然有必要将这些静态方法背后的实现代码块放到单独的
    私有包下的类中。这是因为Java 8需要接口的所有静态成员要是公共的。Java 9 允许私有静态方法。但静态字段和静态成员类仍然需要
    是公共的。
    
  ** 静态工厂的第4个优点是返回对象的类可以根据输入参数的不同而不同**
  
    任何声明的返回类型的子类型都是允许的。返回对象的类也可以根据版本的不同而不同。
    EnumSet类没有公共构造函数，只有静态工厂。在OPENJDK视线中，他们返回两个子类之一的实例，这取决于底层enum类型的大小：
    如果它有64个或更少的元素，想其他大多数enum类型那样，静态工厂返回一个RegularEnumSet实例，底层由单个long实现。
    如果enum类型由65个或者更多元素，工厂返回一个JumboEnumSet实例，基于一个long数组。
    
    这两个实现类的存在对于客户端来说是不透明的。如果RegularEnumSet不再为小型enum类型提供性能优势，它可在未来版本中无副作用
    的废弃。类似，未来版本可能添加第3个或第4个EnumSet的实现如果被认为有性能优势。客户端不知道也不关心他们从工厂返回的对象。
    他们只需要知道它是EnumSet的某个子类。
    
  **第5个关于静态工厂的优点是当包含这个方法的类在编写时不要求返回对象的类存在**
  
    这样的弹性工厂方法形成了提供服务框架的基础，像Java Database Connectivity API(JDBC)。一个服务提供框架是一个系统，
    提供方实现了服务，系统使得实现对于客户端可用，将客户端从实现中解耦出来。
    
    在服务提供框架中有3个重要的组件，一个服务接口，代表了实现；一个提供注册的API，提供方用来注册实现的；和一个
    服务访问API，客户端可以使用获取服务实例。服务访问API可允许客户端指定条件选择实现。如果这样的条件不存在，API
    返回默认实现的实例，或允许客户端遍历所有可用实现。服务访问API是弹性的静态工厂形成了服务提供框架的基础。
    
    一个可选的服务提供框架的第4个组件时服务提供者接口，它描述了生产服务接口实例的工厂对象。如果没有服务提供者
    接口，实现必须通过反射来实例化。在JDBC的例子中，Connection充当了服务接口，DriverManager.registerDriver
    是提供者注册API，DriverManager.getConnection是服务访问API。Driver是服务提供者接口。
    
    有许多服务提供者框架模式的变种。比如，服务访问API可以比服务提供程序提供更丰富的服务接口给客户端。这是桥接模式。
    依赖注入框架可被视为强大的服务提供程序。Java 6以来，平台包含了一个通用目的服务提供程序框架，java.util.ServiceLoader,
    所以你没必要，一般也不该自己写一个。JDBC没有使用ServiceLoader，因为前者早于后者。
     
  **只提供工厂方法的主要限制是没有public或protected构造函数的类不能被继承。
 
    比如，你不可能继承Collections框架的简便实现类。可以说是因祸得福，因为它鼓励程序员使用组合而不是继承。且正好是
    不可变类型需要的。
    
  **第二个缺点是静态工厂方法很难被程序员发现**
  
    他们并没有像构造函数那样显示在API文档中。所以很难弄明白怎么实例化使用静态方法替代构造函数的类的实例。Javadoc工具
    也许某天会关注静态工厂方法。同时，你可以通过关注类或接口文档中的静态工厂，遵循通用命名规范来减轻这个缺点。下面是
    静态工厂方法的通用命名。此列表并非详尽无疑。
    
    - from,一个类型转换方法，接收单个参数，返回这个类型的相关实例。比如
    
        Date d = Date.from(instant);
    - of, 一个聚合方法，接收多个参数返回合并他们后的类型的实例，比如
        
        Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
        
    - valueOf, from和of的更verbose的选择，例如
        
        BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
    - instance 或者 getInstance，返回一个由参数（如果存在的话）描述的实例，但不能说是有相同的值。比如
        
        StackWalker lule = StackWalker.getInstance(options);
    - create or newInstance,和instance或getInstance类似，除了这个方法确保每次都返回一个新实例，例如
        
        Object newArray = Array.newInstance(classObject, arrayLen);
   
    
    
   
   
   
   
   
   
   
   
   
   
   
    
    
